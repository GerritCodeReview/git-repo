{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a268d280_9a634dff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1007145
      },
      "writtenOn": "2021-07-16T07:24:01Z",
      "side": 1,
      "message": "won\u0027t this get checkouts into a bad state ?  if you\u0027re checked out to one commit, then call `git reset` to a diff one, it will mess with the index.\n\n`git clone --no-checkout` works because it\u0027s only the initial checkout operation.  `repo sync` is like both `git clone` \u0026 `git pull`, but --no-checkout only makes sense with the former operation, not the latter.",
      "revId": "72381476e176c18e04f4ed94430659737c0a0bce",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fcd803af_1d0958dd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1091855
      },
      "writtenOn": "2021-07-20T04:54:54Z",
      "side": 1,
      "message": "Yes, this is a challenging case to deal with.\n\nThe intent is to be able to update the state of HEAD without actually updating the working tree so as to provision the underlying source tree from elsewhere, including in non-clone scenarios.\n\nMy memory is a bit foggy on the behaviour of git-repo in this _doff() case, but does this not also touch the index or does the index get ignored here?  In this case, is it more reasonable to do a \u0027reset --soft\u0027 to deal with it? \n\nI seem to recall that there are some behaviours I found unexpected if we have something checked out (eg: I seem to recall that \u0027repo sync\u0027 will send you back to the new upstream HEAD?)\n\nAny suggestions on better approaches would be much appreciated.",
      "parentUuid": "a268d280_9a634dff",
      "revId": "72381476e176c18e04f4ed94430659737c0a0bce",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c790db72_d8a7bab3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1007145
      },
      "writtenOn": "2021-09-29T01:50:50Z",
      "side": 1,
      "message": "i\u0027m pretty sure if HEAD moves but the source checkout doesn\u0027t, git will (rightly so) consider the tree dirty, and will basically be impossible for people to recover without doing a full `git checkout -f` (or equiv).\n\nyou can test this locally:\n\n # Checkout a detached head.\n $ git checkout -f HEAD^\n $ git status\n \u003cclean\u003e\n $ rev\u003d$(git rev-parse HEAD^)\n $ echo $rev \u003e .git/HEAD\n $ git status\n \u003clots of modified files\u003e\n\ni\u0027m still having a hard time understanding what practical use this is by itself.  it seems like you\u0027d still have to run a custom set of commands to get the checkout back into a good/usable state.",
      "parentUuid": "fcd803af_1d0958dd",
      "revId": "72381476e176c18e04f4ed94430659737c0a0bce",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a8977fe_2732f0e7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1091855
      },
      "writtenOn": "2021-09-29T02:42:21Z",
      "side": 1,
      "message": "I can give you an example of how it\u0027s being used to see if that makes much sense ðŸ˜Š\n\nIn our build environment we have scenarios where the source tree is not provisioned directly from our Gerrit instance, it may be provisioned as a base from a container image instead (there is a few other scenarios for us, but the container image is most obvious) which will be shared between build workspaces, but because the git repository state may have user specific configuration it is provisioned at runtime instead.  This helps us to significantly reduce backend load as well as workspace setup time with a large source tree.\n\nTo generalize, if you pre-populate the source tree but need to initialize the repo working environment separate from this, this may be useful.",
      "parentUuid": "c790db72_d8a7bab3",
      "revId": "72381476e176c18e04f4ed94430659737c0a0bce",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8764f96_99c1c881",
        "filename": "subcmds/sync.py",
        "patchSetId": 2
      },
      "lineNbr": 213,
      "author": {
        "id": 1007145
      },
      "writtenOn": "2021-07-16T07:24:01Z",
      "side": 1,
      "message": "we don\u0027t want negative variables as it makes code hard to read.  you can invert this with action\u003dstore_false and default\u003dTrue.",
      "range": {
        "startLine": 213,
        "startChar": 23,
        "endLine": 213,
        "endChar": 34
      },
      "revId": "72381476e176c18e04f4ed94430659737c0a0bce",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "271f8871_13fa068d",
        "filename": "subcmds/sync.py",
        "patchSetId": 2
      },
      "lineNbr": 213,
      "author": {
        "id": 1091855
      },
      "writtenOn": "2021-07-20T04:54:54Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f8764f96_99c1c881",
      "range": {
        "startLine": 213,
        "startChar": 23,
        "endLine": 213,
        "endChar": 34
      },
      "revId": "72381476e176c18e04f4ed94430659737c0a0bce",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}