{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c35fafa6_4a539cee",
        "filename": "release/update-manpages",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1007145
      },
      "writtenOn": "2026-01-08T20:45:31Z",
      "side": 1,
      "message": "i don\u0027t understand the changes to this file at all.  this file is not imported by tests/ which means it isn\u0027t included in `pytest`.  `./run_tests` will run it, but that\u0027s the same as doing `./release/update-manpages`.  are you saying that doesn\u0027t work for you with Python 3.14 unrelated to `./run_tests` ?",
      "revId": "2fb3407bd133fa1d3901da9908a9f30146b3cf9a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "988c18fb_d5255a68",
        "filename": "release/update-manpages",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 4561864
      },
      "writtenOn": "2026-01-09T14:42:47Z",
      "side": 1,
      "message": "yes, w/o this change ./release/update-manpages throws:\nRuntimeError: \n        An attempt has been made to start a new process before the\n        current process has finished its bootstrapping phase.\n\n        This probably means that you are not using fork to start your\n        child processes and you have forgotten to use the proper idiom\n        in the main module:\n\n            if __name__ \u003d\u003d \u0027__main__\u0027:\n                freeze_support()\n                ...\n\n        The \"freeze_support()\" line can be omitted if the program\n        is not going to be frozen to produce an executable.\n\n        To fix this issue, refer to the \"Safe importing of main module\"\n        section in https://docs.python.org/3/library/multiprocessing.html",
      "parentUuid": "c35fafa6_4a539cee",
      "revId": "2fb3407bd133fa1d3901da9908a9f30146b3cf9a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "42fdb546_ccad48f1",
        "filename": "release/update-manpages",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 4577168
      },
      "writtenOn": "2026-01-11T17:57:29Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "988c18fb_d5255a68",
      "revId": "2fb3407bd133fa1d3901da9908a9f30146b3cf9a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c561dc2_80fe8733",
        "filename": "tests/test_subcmds_forall.py",
        "patchSetId": 2
      },
      "lineNbr": 135,
      "author": {
        "id": 1007145
      },
      "writtenOn": "2026-01-08T20:45:31Z",
      "side": 1,
      "message": "i think forcing jobs to 1 for commands all the time makes sense.  it\u0027ll make things more reliable \u0026 consistent across developer systems.  if we have code that we want to make sure to test against multiple threads, then we should do that explicitly (opt-in).\n\nwith that in mind, we should set this in setUp so all forall tests behave this way.  i think you can do it by mocking PARALLEL_JOBS to 1.\n\nmaybe in setUp do:\n\n```\n  # Run tests single threaded by default for stability.\n  self._parallel_jobs_mock \u003d mock.patch.object(subcmds.forall.Forall, \"PARALLEL_JOBS\", 1)\n  self._parallel_jobs_mock.start()\n```\n\nthen in tearDown do:\n\n```\n  self._parallel_jobs_mock.stop()\n```\n\ni haven\u0027t tested this directly",
      "revId": "2fb3407bd133fa1d3901da9908a9f30146b3cf9a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6693d0c4_8be1e0fb",
        "filename": "tests/test_subcmds_forall.py",
        "patchSetId": 2
      },
      "lineNbr": 135,
      "author": {
        "id": 4561864
      },
      "writtenOn": "2026-01-11T17:53:52Z",
      "side": 1,
      "message": "From my point of view there is no general problem with parallel test execution. The problem with this test is though, that it mocks \"GetRevisionId\" and then spawns subprocesses. While this works on Linux, it does not work on macOS and Windows -- because the mock does not transition into the subprocesses. The solution I propose in patch 1 is to not spawn any subprocesses in this specific test case by limiting the parallel jobs to \"1\".",
      "parentUuid": "8c561dc2_80fe8733",
      "revId": "2fb3407bd133fa1d3901da9908a9f30146b3cf9a",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}