{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "843318e4_e751a31d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1007145
      },
      "writtenOn": "2021-03-17T19:47:31Z",
      "side": 1,
      "message": "this changes behavior slightly.  before, if there were local changes, it\u0027d abort.  now it clobbers everything.  i think we want to retain the non-clobber logic.",
      "revId": "71eca6fbdb6616b4e28fa9ef9ea356a6d8339042",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd834070_e9bb00f5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1011842
      },
      "writtenOn": "2021-04-07T18:27:51Z",
      "side": 1,
      "message": "Do you mean if I explicitly `git checkout` a different version in the repo repository in my `.repo`? I think I would prefer if `repo selfupdate` _does_ clobber that, or at least prints an option to.",
      "parentUuid": "843318e4_e751a31d",
      "revId": "71eca6fbdb6616b4e28fa9ef9ea356a6d8339042",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aec16abf_9fa05409",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1007145
      },
      "writtenOn": "2021-04-08T04:18:09Z",
      "side": 1,
      "message": "today, repo selfupdate will do fast forwards and even rebases to a degree.  if your checkout is dirty, it will abort.  so in the situation you describe, it will most likely switch back to the last good state.\n\ni\u0027m talking about going into .repo/repo/ and making changes (presumably for testing), and those getting blown away.  today, we don\u0027t do that.",
      "parentUuid": "cd834070_e9bb00f5",
      "revId": "71eca6fbdb6616b4e28fa9ef9ea356a6d8339042",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b210d4c6_d5b83d16",
        "filename": "subcmds/sync.py",
        "patchSetId": 1
      },
      "lineNbr": 992,
      "author": {
        "id": 1011842
      },
      "writtenOn": "2021-04-08T05:50:26Z",
      "side": 1,
      "message": "I think `--keep` here would do most of what we want (carrying forward any local uncommitted changes, like _Checkout does).\n\nThe main thing it\u0027s missing in the detached-head case is the \"discarding %d commits\" message. If we want to only allow fast-forwards, we could instead do `merge(\u0027--ff-only\u0027, new_rev)`.\n\nIf the user is on a named branch, then this is missing the check for unmerged changes, etc.\n\nSo I think we have three options:\n\na. We could encourage users to use a branch other than `main` and always have the tip have a signed tag pointing to it\nb. We could encourage users to disable checking for a signed tag and rely on TLS instead\nc. We could teach Sync_LocalHalf to take a parameter that overrides revid and use that instead of `git reset --hard`\n\n(c) seems simplest.",
      "range": {
        "startLine": 992,
        "startChar": 25,
        "endLine": 992,
        "endChar": 31
      },
      "revId": "71eca6fbdb6616b4e28fa9ef9ea356a6d8339042",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f0c5da7_b5804acf",
        "filename": "subcmds/sync.py",
        "patchSetId": 1
      },
      "lineNbr": 992,
      "author": {
        "id": 1007145
      },
      "writtenOn": "2021-04-08T14:54:06Z",
      "side": 1,
      "message": "i like the reset --keep option best.  we need to be able to rollback, and merge/ff-only wouldn\u0027t support that.\n\nwrt signed tags \u0026 TLS, i think the experience thus far is that external people are happy to (ab)use things whenever possible, so i\u0027m not keen on that.  plus, signed tags are nice in that it further restricts who can push a release.  i don\u0027t mean this in a power-grab type of way, but in a way that makes it harder for attackers to push unverified code.  there\u0027s a lot more people who have write access to this git repo than have access to the keys for signing :).",
      "parentUuid": "b210d4c6_d5b83d16",
      "range": {
        "startLine": 992,
        "startChar": 25,
        "endLine": 992,
        "endChar": 31
      },
      "revId": "71eca6fbdb6616b4e28fa9ef9ea356a6d8339042",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "46a9fa37_21f7be4a",
        "filename": "subcmds/sync.py",
        "patchSetId": 1
      },
      "lineNbr": 992,
      "author": {
        "id": 1011842
      },
      "writtenOn": "2021-04-09T01:13:30Z",
      "side": 1,
      "message": "FWIW, I like what you have here. :)",
      "parentUuid": "5f0c5da7_b5804acf",
      "range": {
        "startLine": 992,
        "startChar": 25,
        "endLine": 992,
        "endChar": 31
      },
      "revId": "71eca6fbdb6616b4e28fa9ef9ea356a6d8339042",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}